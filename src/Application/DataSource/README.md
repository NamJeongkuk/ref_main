# Overview
The goals of this configuration are to:
- Make the data source easily extensible
- Provide O(log(n)) (or better) runtime complexity for all operations
- Make `SystemErds.h` easily editable
  - Only one table of ERDs
  - ERD numbers only need to be in ascending order
  - ERDs of different types can be interleaved

## Performance
The configuration table in `SystemErds.h` gives the external ERD number for all ERDs. Internally, RAM ERDs are auto-enumerated from `RamErdBase` and ERDs of all other types use the same number internally and externally. In order to ensure that there's never a conflict between an auto-enumerated RAM ERD and any other type of ERD, all external ERD numbers are assigned such that they are less than `RamErdBase`.

This configuration allows the RAM ERDs to be found using direct index lookups and all other ERDs to be found using binary search. Since RAM ERDs are the fastest and most frequently used, the RAM data source is put into the composite data source first. This ensures that RAM lookups are performed first.

Further, the fact that all external ERDs are in ascending order and only RAM ERDs need to be swapped means that mapping from external to internal ERDs can be done in O(log(n)) using binary search and mapping from internal to external ERDs can be done in O(1) time using direct index lookup.

So, RAM ERDs can be located and read in constant time and then when they are written they can be located _and_ mapped externally in constant time. Thus for the most frequent operations, we have constant time performance.

## Components
The `SystemData_t` component combines all of the separate data sources into one data source, maps and swaps its endianness for external use, and wraps it into a data model. It uses a non-static composite data source to make this process easy and to allow data sources that have a recursive dependency on the data source to be integrated into one data source without several levels of composites being used. This has a small RAM cost, but greatly simplifies the configuration.

### BSP Data Source
The BSP data source encapsulates all of the hardware-specific code for the project. If configured correctly, it should be the only component that needs to change when moving to a new board.

Because it should not require changes elsewhere, it will often need to present a higher level of abstraction than GPIO and ADC. For example, if a sensor requires input capture for reading the feedback, the BSP data source should not expose the low-level configuration of the timer peripheral for the application to use nor should it return feedback values in non-portable units such as timer ticks. Instead, the BSP data source should be responsible for taking the measurement (including any handling of timer overflows) and convert it to a portable unit such as microseconds and make this available to the application. This will allow the measurement to be done using an entirely different input capture peripheral or even without using a real input capture peripheral without impacting the appliation.

### RAM Data Source
The RAM data source stores ERDs in RAM. Most application-specific ERDs will be stored here.

### Non-Volatile Data Source
The non-volatile data source stores ERDs that need their values to be retained through a power cycle. There are two primary back-ends for NV storage: data flash and EEPROM.

### Service Diagnostics Data Source
The service diagnostics data source manages (almost) all of the ERDs required to host service diagnostics rev 3 entities. It also hosts fault ERDs that the application can use to set/clear faults and read their status. These fault ERDs do not consume any RAM and their values are generated by reading the fault table ERDs. This means that the service diagnostics memory usage is proportional to the size of the fault tables/sequences/etc., not the total number of faults supported by the system.

### Appliance API Data Source
The appliance API data source manages the [_common_ appliance API ERDs](https://github.com/geappliances/documentation.appliance-api/blob/master/doc/common.md). Product-line specific appliance feature APIs must be managed by the application.

### External Data Source
The external data source handles mapping external ERDs to internal ERDs (where appropriate) and swapping the endianness of ERDs with endianness-dependent representations so that they are available in a big endian representation to GEA2 clients. It accomplishes this through the use of a mapped data source and an endianness-swapped data source.

In this configuration only a subset of the ERDs need to be mapped. In order to reduce the size of the lookup table and to allow a more efficient search, only these ERDs are mapped. All unmapped ERDs are available via pass through because the mapped data source is initialized with `DataSource_Mapped_InitWithPassThrough`.

Additionally, the endianness swapping component is initialized with `swapOnPublish` set to `false`. This option was chosen so that the cost of swapping endianness for external clients isn't paid for every internal write. All common components that are designed for use with an external data source assume that the external data source is configured in this way and thus do not depend upon publications to be swapped.
